[{"categories":["軟體設計"],"contents":" C語言的巨集（#define）和function call是在程式碼中實現相同目標的兩種不同方法。然而，它們在空間和速度方面存在重要區別。\n空間上的差異： 巨集在編譯時會被展開成實際程式碼，因此可能增加記憶體消耗。當使用多個巨集時，前置處理後的程式碼會變得更大，可能導致可執行檔體積增加。 function call使用相對較小的空間，因為函數代碼只在程式運行時複製到堆疊，不會在編譯過程中展開。\n速度上的差異： 巨集的展開在編譯時完成，通常更快速。function call需要堆疊操作，如push和pop，這可能涉及更多指令執行，速度較慢。 巨集具有效能優勢，但有可能降低代碼的可讀性。\n在實際程式設計中，選擇使用巨集或function call應基於特定需求和效能目標，需要權衡這些因素。\n","permalink":"https://Menglin31.github.io/blog/define/","tags":["Code","C"],"title":"Define macro vs function"},{"categories":["Authontication"],"contents":" Session-based Authontication 利用Session來進行驗證的機制 流程如下圖 Note: Http cookie 位於 Http request header中的小區塊，自動存於client side。 Token based Authentication 流程如下圖 Note：server不需要儲存任何資料，token由client保管 Difference: Session based 利用cookie傳遞資料，cookie只要同網域下的請求都會帶上。 CSRF(Cross Site Request Forgery): Eve可用他的網站去連線Alice網站的API，就可以更動Database。 如果環境被監聽(MitM, Men in the Middle Attack)，則兩種都不安全。 可以用SSL加密解決。 Session based中，每次session建立，都需要儲存空間，儲存辨識使用者的資料。 Token based中，辨識使用者的資料則是交給token進行儲存，不需要很大的伺服器空間，相同空間的情況下，能服務的使用者較多，但伺服器無法主動結束一個token，只能等token自己到期。 ","permalink":"https://Menglin31.github.io/blog/authentication/","tags":["Authontication","note"],"title":"Session-based Authentication v.s. Token-based Authentication"},{"categories":["tips"],"contents":" 官方Demo https://www.youtube.com/watch?v=I2jOuLU4o8E\n作用機制 usb ip protocol\nsystem environment\nwin11, wsl version 2 setup\ninstall usbip tools in WSL sudo apt install linux-tools-generic hwdata\rsudo update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20 install usbip in windows 11 winget install --interactive --exact dorssel.usbipd-win reboot windows open powershell in administrator mode\nlist all of the USB devices connected to Windows usbipd wsl list select the bus ID of the device you’d like to attach usbipd wsl attach --busid \u0026lt;busid\u0026gt; select the bus ID of the device you’d like to detach usbipd wsl detach --busid \u0026lt;busid\u0026gt; in WSL\nlist the attached USB devices lsusb disk in win11 目前官方無提供讀ext4解法\n可能有用的解法(待嘗試) -\u0026gt; 可mount usb https://www.youtube.com/watch?v=iyBfQXmyH4o WSL2中會用到的指令如下 VERSION=5.10.60.1 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt install -y build-essential flex bison libgtk2.0-dev libelf-dev libncurses-dev autoconf libudev-dev libtool zip unzip v4l-utils libssl-dev python3-pip cmake git iputils-ping net-tools dwarves sudo mkdir /usr/src cd /usr/src sudo git clone -b linux-msft-wsl-${VERSION} https://github.com/microsoft/WSL2-Linux-Kernel.git ${VERSION}-microsoft-standard \u0026amp;\u0026amp; cd ${VERSION}-microsoft-standard sudo cp /proc/config.gz config.gz sudo gunzip config.gz sudo mv config .config sudo make menuconfig 這邊要把 menuconfig -\u0026gt; Device Drivers \u0026ndash;\u0026gt; USB support \u0026mdash;\u0026gt; USB Mass Storage support 按y選取 按esc+esc儲存並跳出 sudo make -j$(nproc) sudo make modules_install -j$(nproc) sudo make install -j$(nproc) sudo cp -rf vmlinux /mnt/c/Sources/ exit 接著再win11底下 wsl --shutdown 確認/mnt/c/Sources/中有無vmlinux 這個檔案 C:\\Users\\\u0026lt;username\u0026gt; (需替換成自己使用者名字)在這個路徑下新建一個檔案 .wslconfig .wslconfig內容為vmlinux的路徑 kernel=C:\\Sources\\vmlinux mount/unmount usb 指令(要先attach usb到wsl) win11終端機內輸入wsl lsblk sudo mkdir /mnt/part1 sudo mount /dev/sdd1 /mnt/part1 即可在/mnt/part資料夾中看到usb內的資料 unmount則 sudo unmount /dev/sdd1 Reference\nhttps://learn.microsoft.com/en-us/windows/wsl/connect-usb https://gitlab.com/alelec/wsl-usb-gui ","permalink":"https://Menglin31.github.io/blog/wsl_usb/","tags":["WSL","USB","tips"],"title":"Attach USB Device to WSL2"},{"categories":["軟體設計"],"contents":" SOLID設計原則 SRP: 單一職責原則 軟體產品的架構與開發團隊的組織會相互影響。 每個軟體模組只有一個理由需要改變。\nOCP: 開放\u0026ndash;封閉原則 要使軟體系統易於改變，須將其設計成允許透過增加新程式碼來更改行為（而非更改現有程式）。\nLSP: Liskov替換原則 建置軟體系統必須來自可互換的部分，這些部分必須遵守允許這些部分相互替換的契約。\nISP: 介面隔離原則 軟體設計師應該避免依賴於不使用的東西。\nDIP: 依賴反向原則 實作策略的高層程式碼不應該依賴於實作細節的低層級程式碼 → 細節應該依賴於策略\nSRP(Single Responsibility Principle)，單一職責原則 一個模組應該只對唯一的一個角色負責 狀況一： 假設工程師正在為應用程式建立一個class進行用戶身份驗證。 該class可能具有以下職責： 驗證用戶的憑證（例如用戶名和密碼）。 從資料庫中查詢用戶資料。 為用戶生成身份驗證的token。 但是，根據單一職責原則，一個class應該只有一個原因需要進行更改。 換句話說，一個class只應該有一個職責。 因此，在這種情況下，最好將職責分成下列幾個單獨的class： 驗證用戶的憑證的class。 從資料庫中查詢用戶資料的class。 為用戶生成身份驗證token的class。 這將產生更容易理解和維護的代碼，因為每個class都有一個明確且具體的職責。 如果其中一個職責發生變化，只需要更新相關的class，而不是對處理所有三個職責的單個class進行更改。\n","permalink":"https://Menglin31.github.io/blog/design_solid/","tags":["Code","SOLID"],"title":"SLOID設計原則"},{"categories":["版本控制"],"contents":" git branch，建立自己的Branch(ex: git branch ABC-49267) git checkout ABC-49267 git add git commit -m \u0026ldquo;commit message\u0026rdquo; git pull遠端處理的版本(ex:git pull origin 1.0.0-branch) git push 自己的分支(ex: git push origin ABC-0001) github上發PR 設定reviewer 改branch name 切到該分支底下 輸入 git branch -m \u0026lt;new branch name\u0026gt; ","permalink":"https://Menglin31.github.io/blog/git/","tags":["Code","git","version control"],"title":"Git常用指令"}]