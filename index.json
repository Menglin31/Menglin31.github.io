[{"categories":["生活"],"contents":" 泳池 費用 泳池長度 人數 吹風機 水道寬度 深水區 水溫 SPA池 更衣室乾淨度 其他評價 師大游泳池 $150 50m 人不多 免費 寬 有 約 30 度 有 乾淨 目前游過最舒適的泳池！ 師大附中游泳池 $110 50m 人稍多 免費 略窄 無 約 29 度 無 乾淨 室內有點悶, 無氯，聽說游了皮膚會變好（？） 萬華青年育樂中心 $110 50m 人不多 $10 寬 無 冬天 27-28 度 無 乾淨 地板很刺, 過於通風冬天很冷 中正運動中心 $110 50m 人很多 $10 也可以跟1F櫃檯借用不用錢 寬 無 28-29 度 有 中等 門口機車格很多，中心有付費停車場 想去還沒去：國北教大泳健館、大安運動中心\n","permalink":"https://Menglin31.github.io/blog/swim/","tags":["Sports"],"title":"台北市游泳池評比"},{"categories":["生活"],"contents":"品牌: TRYALL 碗豆蛋白 口味 評價 分數 花生可可 還不錯，加水不難喝 3.5 紅豆拿鐵 茶味很香，但有微微甜味劑的味道，有完整的紅豆（但不好吃），加溫水還不錯喝，喝到後來有點甜，甜度\u0026gt;花生可可，甜味扣0.5分 3.5 芋頭牛奶 不難喝，不好喝 3.0 功夫紅茶 太甜了 2.5 可可 不錯，略勝花生可可，可惜只有出小包裝 3.7 芝麻奶 除了有點甜以外都不錯 3.8 杏仁奶 有點像真的，但本身就對杏仁奶沒愛 3.4 冬瓜鐵觀音 喝到後面有點甜 3.0 焙茶奶 不知道是不是搖太大力，泡泡好多好難喝 2.0 小包裝可回購: 紅豆拿鐵、可可、芝麻奶\n大包裝持續回購中: 花生可可\n大豆蛋白 口味 評價 分數 紅茶 好難喝@@ 1.0 喝過一次大豆蛋白後就再也沒買過了\u0026hellip;\n","permalink":"https://Menglin31.github.io/blog/protein/","tags":["Sports"],"title":"植物性高蛋白評比"},{"categories":["Algorithm"],"contents":"最長共同子序列(Longest Common Subsequence ,LCS) 是一個經典的問題，涉及查找兩個給定字串中以相同順序出現的最長字元序列。這個問題有多種應用，包括 DNA 序列分析、文字比較和版本控制系統。\n四個步驟 把大問題和小問題之間的關係(特徵)找出來\n在 LCS 問題中，常見兩個字串的 LCS 可以從其子字串的 LCS 建構出來。 找到關係後，寫遞迴關係式\n一旦大問題和小問題之間的關係建立起來，下一步就是製定遞迴關係。 遞迴關係根據子問題的解來定義問題的解。 對於 LCS 問題，遞迴關係是基於比較兩個字串的最後一個字元。 設C[i][j]表示字串X的前i個字元和字串Y的前j個字元的LCS長度。遞迴關係為： C[i-1][j-1] + 1, if X[i] = Y[j] max(C[i-1][j], C[i][j-1]), if X[i] ≠ Y[j] 從小問題最佳解，解出來後填入表格，一步一步往上，再解出大問題，大問題可透過查表得到答案。\n建立一個表格來儲存子問題的解決方案。 已經有大表格後，可以透過原本的表格，找過最小的問題是怎麼得到的。\n一旦表格完成，原始問題的解決方案（完整字串的 LCS）將在表格的最後一個單元格中找到 即 C[m][n]，其中 m 和 n 是輸入字串的長度分別為X 和Y。 結論：\n為了解決最長共同子序列問題，動態規劃方法提供了一種有效且有系統的方法來尋找最優解決方案。透過將問題分解為更小的子問題並利用它們的解決方案，可以避免多餘計算並實現 O(m * n) 的時間複雜度（其中 m 和 n 是輸入字串的長度）。 此方法目前廣泛應用於各種序列配對問題。\n","permalink":"https://Menglin31.github.io/blog/dp/","tags":["DP","Leetcode","LCS"],"title":"Dynamic Programming"},{"categories":["軟體設計"],"contents":" C語言的巨集（#define）和function call是在程式碼中實現相同目標的兩種不同方法。不過，它們在空間和速度方面存在重要區別。\n空間上的差異： 巨集在編譯時會被展開成實際程式碼，因此可能增加記憶體消耗。當使用多個巨集時，前置處理後的程式碼會變得更大，可能導致可執行檔體積增加。 function call使用相對較小的空間，因為函數代碼只在程式運行時複製到堆疊，不會在編譯過程中展開。\n速度上的差異： 巨集的展開在編譯時完成，通常更快速。Function call需要堆疊操作，如push和pop，這可能涉及更多指令執行，速度較慢。 巨集具有效能優勢，但有可能降低代碼的可讀性。\n在實際程式設計中，選擇使用巨集或function call應基於特定需求和效能目標，需要權衡這些因素。\n","permalink":"https://Menglin31.github.io/blog/define/","tags":["Code","C"],"title":"Define macro vs function"},{"categories":["Authontication"],"contents":"Session-based Authontication 利用Session來進行驗證的機制 流程如下圖 Note: Http cookie 位於 Http request header中的小區塊，自動存於client side。 Token based Authentication 流程如下圖 Note：server不需要儲存任何資料，token由client保管 Difference: Session based 利用cookie傳遞資料，cookie只要同網域下的請求都會帶上。 CSRF(Cross Site Request Forgery): Eve可用他的網站去連線Alice網站的API，就可以更動Database。 如果環境被監聽(MitM, Men in the Middle Attack)，則兩種都不安全。 可以用SSL加密解決。 Session based中，每次session建立，都需要儲存空間，儲存辨識使用者的資料。 Token based中，辨識使用者的資料則是交給token進行儲存，不需要很大的伺服器空間，相同空間的情況下，能服務的使用者較多，但伺服器無法主動結束一個token，只能等token自己到期。 ","permalink":"https://Menglin31.github.io/blog/authentication/","tags":null,"title":"Session-based Authentication v.s. Token-based Authentication"},{"categories":["tips"],"contents":" 官方Demo https://www.youtube.com/watch?v=I2jOuLU4o8E\n作用機制 usb ip protocol\nsystem environment\nwin11, wsl version 2 setup\ninstall usbip tools in WSL sudo apt install linux-tools-generic hwdata\rsudo update-alternatives --install /usr/local/bin/usbip usbip /usr/lib/linux-tools/*-generic/usbip 20 install usbip in windows 11 winget install --interactive --exact dorssel.usbipd-win reboot windows open powershell in administrator mode\nlist all of the USB devices connected to Windows usbipd wsl list select the bus ID of the device you’d like to attach usbipd wsl attach --busid \u0026lt;busid\u0026gt; select the bus ID of the device you’d like to detach usbipd wsl detach --busid \u0026lt;busid\u0026gt; in WSL\nlist the attached USB devices lsusb disk in win11 目前官方無提供讀ext4解法\n可能有用的解法(待嘗試) -\u0026gt; 可mount usb https://www.youtube.com/watch?v=iyBfQXmyH4o WSL2中會用到的指令如下 VERSION=5.10.60.1 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y \u0026amp;\u0026amp; sudo apt install -y build-essential flex bison libgtk2.0-dev libelf-dev libncurses-dev autoconf libudev-dev libtool zip unzip v4l-utils libssl-dev python3-pip cmake git iputils-ping net-tools dwarves sudo mkdir /usr/src cd /usr/src sudo git clone -b linux-msft-wsl-${VERSION} https://github.com/microsoft/WSL2-Linux-Kernel.git ${VERSION}-microsoft-standard \u0026amp;\u0026amp; cd ${VERSION}-microsoft-standard sudo cp /proc/config.gz config.gz sudo gunzip config.gz sudo mv config .config sudo make menuconfig 這邊要把 menuconfig -\u0026gt; Device Drivers \u0026ndash;\u0026gt; USB support \u0026mdash;\u0026gt; USB Mass Storage support 按y選取 按esc+esc儲存並跳出 sudo make -j$(nproc) sudo make modules_install -j$(nproc) sudo make install -j$(nproc) sudo cp -rf vmlinux /mnt/c/Sources/ exit 接著再win11底下 wsl --shutdown 確認/mnt/c/Sources/中有無vmlinux 這個檔案 C:\\Users\\\u0026lt;username\u0026gt; (需替換成自己使用者名字)在這個路徑下新建一個檔案 .wslconfig .wslconfig內容為vmlinux的路徑 kernel=C:\\Sources\\vmlinux mount/unmount usb 指令(要先attach usb到wsl) win11終端機內輸入wsl lsblk sudo mkdir /mnt/part1 sudo mount /dev/sdd1 /mnt/part1 即可在/mnt/part資料夾中看到usb內的資料 unmount則 sudo unmount /dev/sdd1 Reference\nhttps://learn.microsoft.com/en-us/windows/wsl/connect-usb https://gitlab.com/alelec/wsl-usb-gui ","permalink":"https://Menglin31.github.io/blog/wsl_usb/","tags":["WSL","USB","tips"],"title":"Attach USB Device to WSL2"},{"categories":["軟體設計"],"contents":" SOLID設計原則 SRP: 單一職責原則 軟體產品的架構與開發團隊的組織會相互影響。 每個軟體模組只有一個理由需要改變。\nOCP: 開放\u0026ndash;封閉原則 要使軟體系統易於改變，須將其設計成允許透過增加新程式碼來更改行為（而非更改現有程式）。\nLSP: Liskov替換原則 建置軟體系統必須來自可互換的部分，這些部分必須遵守允許這些部分相互替換的契約。\nISP: 介面隔離原則 軟體設計師應該避免依賴於不使用的東西。\nDIP: 依賴反向原則 實作策略的高層程式碼不應該依賴於實作細節的低層級程式碼 → 細節應該依賴於策略\nSRP(Single Responsibility Principle)，單一職責原則 一個模組應該只對唯一的一個角色負責 狀況一： 假設工程師正在為應用程式建立一個class進行用戶身份驗證。 該class可能具有以下職責： 驗證用戶的憑證（例如用戶名和密碼）。 從資料庫中查詢用戶資料。 為用戶生成身份驗證的token。 但是，根據單一職責原則，一個class應該只有一個原因需要進行更改。 換句話說，一個class只應該有一個職責。 因此，在這種情況下，最好將職責分成下列幾個單獨的class： 驗證用戶的憑證的class。 從資料庫中查詢用戶資料的class。 為用戶生成身份驗證token的class。 這將產生更容易理解和維護的代碼，因為每個class都有一個明確且具體的職責。 如果其中一個職責發生變化，只需要更新相關的class，而不是對處理所有三個職責的單個class進行更改。\n","permalink":"https://Menglin31.github.io/blog/design_solid/","tags":["Code","SOLID"],"title":"SLOID設計原則"},{"categories":["版本控制"],"contents":" git branch，建立自己的Branch(ex: git branch ABC-49267) git checkout ABC-49267 git add git commit -m \u0026ldquo;commit message\u0026rdquo; git pull遠端處理的版本(ex:git pull origin 1.0.0-branch) git push 自己的分支(ex: git push origin ABC-0001) github上發PR 設定reviewer 改branch name 切到該分支底下 輸入 git branch -m \u0026lt;new branch name\u0026gt; ","permalink":"https://Menglin31.github.io/blog/git/","tags":["Code","git","version control"],"title":"Git常用指令"},{"categories":["Arduino"],"contents":"最近閒閒沒事突然想回味小時候玩的板子，順手把玩過的模組記錄下來。\n會先用流水帳的方式寫，有餘力再補充相關知識。\nW104聲音模組 實作 W104 聲音模組，偵測到聲音即透過外接 RGB 燈全彩模組亮燈。\nW104 這款聲音模組配有電容式麥克風，比較常用在聲音警報系統中。\n聲音模組的靈敏度可以使用一字起子調整 W104 上的可變電阻，順時針會提高輸出的門檻值。\n接法： 範例程式碼：\nconst int Red = 9; //腳位 const int Green = 10; const int Blue = 11; void setup() { Serial.begin(9600); pinMode(Red, OUTPUT); pinMode(Green, OUTPUT); pinMode(Blue, OUTPUT); } void loop() { int r, g, b; int sensorValue = analogRead(A0); int lightValue = (sensorValue)%255; // 每個原色可以有0-255的變化，這邊可根據聲音靈敏度調整參數 Serial.println(lightValue); if (lightValue \u0026gt; 255) { analogWrite(Red, 255); } else { analogWrite(Red, sensorValue); } delay(10); } RGB 全彩模組實作細節可以參考這篇\n","permalink":"https://Menglin31.github.io/blog/arduino_sound/","tags":null,"title":" Arduino 聲音感測模組 W104"}]